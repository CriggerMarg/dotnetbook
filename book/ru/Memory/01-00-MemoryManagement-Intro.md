>[Содержание](../readme.md)

# Основы управления памятью

## Введение

Когда вы думали о разработке любого .NET приложения до недавних пор, можно было себе позволить считать, что приложение, которое вы делаете, будет всегда работать на одной и той же платформе: это операционная система Windows, запущенная поверх технологического стека Intel. Сейчас же, с каждым прожитым днем мы входим в новую эпоху: платформа .NET стала поистине кроссплатформенной, пустив новые корни в сторону всех доступных настольных операционных систем. Это прекрасное время и наш долг -- не потерять нить и остаться востребованными специалистами. Ведь когда toolset становится кроссплатформенным, это означает что мы обязаны начать смотреть внутрь. Изучать, как работает двигатель нашей платформы, чтобы понимать, почему тот ведет себя так или иначе на различных системах.

Вторая мысль, которую мне хотелось бы передать через страницы данной книги: даже если ваши сервера будут сверхпроизводительными, даже если они будут настолько быстрыми, что будет казаться, что оптимизации -- последнее дело, о котором стоит думать... Вы всё равно начнёте оптимизировать код. Вспомните: когда-то всем известный системный программист Билл Гейтс сказал, что 640 Кб памяти должно хватить любому. И на тот момент это было правдой. И на тот момент если скажи любому, что через каких-то 20 лет один компьютер сможет заменить несколько тысяч серверов того времени, вам бы сказали: в ваше время производительность настолько высокая, что над оптимизацией наверняка не стоит даже задумываться. Но что мы видим? Всё большее количество людей уходит в онлайн. Всё большее количество людей начинает пользоваться смартфонами и, как следствие, онлайн торговлей. А этим системам чтобы выдерживать всё нарастающие нагрузки хочется сэкономить: арендовывать меньшее количество серверов при всё нарастающей нагрузке. И поверьте: эпоха сети Интернет только взяла старт: в прошлое уйдёт население, не принимающее современных технологий, а на смену ему придёт поколение, не знающее другого пути. И даже если серверные системы будущего будут выдерживать нагрузки в 1,000 раз большие.. Конечно же сайты "попроще" могут быть написаны как угодно плохо... Но если ваша цель -- работать в компаниях топового уровня, оптимизацией вы будете заниматься всегда.

[>]: Касательно этого вопроса, конечно же, может существовать множество мнений. Однако, как опыт так и статистика по зарплатам на различных порталах говорит нам о том, что вектор развития индустрии именно такой.

Программисты, на мой взгляд, разделятся если можно так выразиться на классы: это деление уже в некотором смысле началось. Однако сегментация будет более выраженной: на мой взгляд сливки будут снимать люди с хорошим математическим аппаратом. Эти люди будут решать вопросы разработки систем ИИ, нейросетей, потокового шифрования и передачи больших объёмов траффика. Вопросы кратко- и долгосрочного хранения данных, высокоскоростного извлечения данных по нечётким критериям, ассоциативным критериям. Распознания и синтеза образов и речи. Системы слежения за всеми аспектами жизни людей и продажи этой информации через API. Эта работа возможна только со знанием математического аппарата и с глубоким знанием платформы, на которой идёт работа. Обилие вывода разработчиков ВУЗами создаст избыточное предложение, излишки которого будут заниматься настройкой шаблонов "под магазин". Они будут мастера этого дела: ведь работа эта -- потоковая. И каждый из классов будет, как это принято, иметь зарплатную вилку. Уйти в верхнюю зарплатную вилку помимо всего прочего вам помогут страницы этой книги. Ровно как и создать её этими знаниями.

>{.big-quote} Рынок высокопроизводительного программного обеспечения создаётся наличием профессионалов, которые своей работой сами создают спрос на себя.

Подсистему управления памятью мы будем изучать слой за слоем. Начнем от слоя, близкого к пониманию ее работы "на пальцах" и закончим -- слоем архитектуры на самом низком уровне -- процессорном. Ведь чтобы до конца понимать всю проблематику работы с памятью -- надо знать все, начиная от процессорных кэшей заканчивая оптимизациями работы c кучами .NET.

## Основы основ

Если взять любое приложение и попробовать грубо разделить его на две части, то получится, что любое приложение состоит фактически из двух самых важных вещей: кода, который исполняется процессором, и данных, которыми этот код оперирует в своей работе. Причем если с кодом все более-менее ясно, то данные можно поделить на несколько больших секций:

[>]: Самым большим вопросом при формировании линии повествования был вопрос выбора тем: что конкретно включать в книгу? Понятно, что работа с памятью и библиотека, определяющая модель работы в многопоточной среде включены быть должны в полоном (но адекватном) объеме. Однако не только ими формируется платформа. 

    Что ещё включать в архитектуру, а что -- оставить за бортом как часть BCL? Ведь BCL одними своими частями задаёт тон всему .NET: определяет архитектуру ваших приложений. С другой -- являетя библиотекой стандартных классов.

- **Thread stack** -- область памяти, которая есть у любого потока и через которую работают все вызовы всех методов, плюс там же организовано хранилище для локальных переменных методов.
- **Code Heap** -- область памяти, куда JITter складывает результаты компиляции MSIL.
- **Small Objects Heap** -- куча маленьких объектов. Как бы это не звучало, именно так это и называется. По своей сути это хранилище объектов, размер которых не превышает 85 кб.
- **Large Objects Heap** -- это куча больших объектов. Сюда попадают объекты, размеры которых превышают 85 кб.
- **TypeRefs Heap** -- куча Type References -- описателей типов .NET -- со стороны подсистемы CLR. со стороны .NET типов выступает подсистема Reflection.
- **MethodRefs Heap** -- куча Methods References -- описателей методов .NET -- со стороны подсистемы CLR. Со стороны .NET типов также выступает подсистема Reflection.
- И многие другие
